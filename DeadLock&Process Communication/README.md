- 死锁

- 进程访问资源的流程
  - 资源类型 R1，R2..
    - CPU 执行时间、内存空间、I/O
  - 每类资源 Ri 有 Wi 个实例
  - 流程
    - 请求/获取
      申请空闲
    - 使用/占用
      进程占用
    - 释放
      占用->空闲
- 资源分类
  - 可重用
    - 不能被删除，only one whenever
    - 示例
      - 硬：cpu，I/O，ram，device
      - 软：doc、database、mutex
    - 可能出现死锁
  - 消耗
    - 创建和销毁
    - 示例
      - 缓冲区的中断、信号、消息等
    - 可能出现死锁，互相等待对方
- 资源分配图
  - 两类顶点
    - all procs P={P1,P2,..,Pn}
    - all res R={R1,R2..}
  - 两类有向边
    - 请求边
    - 分配边
- 出现死锁条件【缺一不可！】
  - 互斥
  - 持有并等待
  - 非抢占
  - 循环等待
- 死锁处理

  - 死锁预防 - 确保系统永远不会进入死锁状态（CPU 利用率比较低
    - 限制申请方式，使系统在任何时刻都不满足死锁的必要条件
      1. 去互斥 ： 把互斥的共享资源封装成可同时访问
      2. 去持有并等待 ： proc 申请时，要求它不持有其他任何资源；进程开始执行时，一次申请所有需要的资源
      3. 去非抢占 ： if 进程请求不能立即分配的 res，则释放已占有资源
      4. 去循环等待 ： 对 res 排序，要求进程按顺序申请
  - 死锁避免 - 使用前判断，只允许不会出现死锁的进程请求资源
    - 利用额外的先验信息，在分配 res 是判断是否会出现死锁，不会死锁时才分配
      1. 要求进程生命需要的资源的**最大**数目
      2. **限定**提供与分配的资源数量，确保满足进程的最大需求
      3. **动态检查**资源分配状态，确保不会出现环形等待
  - 死锁检测和恢复 - 检测进入死锁后，恢复

  - 通常 OS 忽略死锁，交给应用进程处理

- 银行家

  线程数目：n
  资源类型数量：m

  - MAX：nxm
  - Available：m
  - Allocation：nxm
  - Need：nxm
